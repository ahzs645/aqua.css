<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cursor Generator</title>
    <style>
        body {
            background-color: #222;
            color: #eee;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            padding: 40px;
        }

        .container {
            max-width: 800px;
            margin: 0 auto;
        }

        h1 {
            margin-bottom: 10px;
        }

        .subtitle {
            color: #888;
            margin-bottom: 30px;
        }

        .preview-section {
            display: flex;
            gap: 40px;
            align-items: flex-start;
            margin-bottom: 30px;
        }

        .spinner-preview {
            background: #333;
            padding: 20px;
            border-radius: 12px;
        }

        .spinner-preview canvas {
            display: block;
        }

        .frames-preview {
            flex: 1;
        }

        .frames-preview h3 {
            margin-top: 0;
        }

        .frames-grid {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            max-height: 200px;
            overflow-y: auto;
            background: #333;
            padding: 10px;
            border-radius: 8px;
        }

        .frames-grid canvas {
            background: transparent;
            border: 1px solid #444;
            border-radius: 4px;
        }

        .controls {
            background: #333;
            padding: 20px;
            border-radius: 12px;
            margin-bottom: 20px;
        }

        .control-row {
            display: flex;
            gap: 20px;
            margin-bottom: 15px;
            align-items: center;
        }

        .control-row label {
            min-width: 120px;
        }

        input[type="range"] {
            flex: 1;
            accent-color: #007aff;
        }

        .value {
            min-width: 50px;
            text-align: right;
            color: #888;
        }

        .buttons {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
        }

        button {
            background: #007aff;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            font-size: 16px;
            cursor: pointer;
            transition: background 0.2s;
        }

        button:hover {
            background: #0056b3;
        }

        button:disabled {
            background: #555;
            cursor: not-allowed;
        }

        .info {
            background: #2a2a2a;
            padding: 15px;
            border-radius: 8px;
            margin-top: 20px;
            font-size: 14px;
            color: #aaa;
        }

        .info code {
            background: #444;
            padding: 2px 6px;
            border-radius: 4px;
            color: #fff;
        }

        .status {
            margin-top: 15px;
            padding: 10px;
            border-radius: 6px;
            display: none;
        }

        .status.success {
            display: block;
            background: #1a4d1a;
            color: #4ade4a;
        }

        .status.error {
            display: block;
            background: #4d1a1a;
            color: #de4a4a;
        }

        /* Cursor follower */
        #cursorFollower {
            position: fixed;
            pointer-events: none;
            z-index: 9999;
            display: none;
        }

        body.cursor-active {
            cursor: none !important;
        }

        body.cursor-active * {
            cursor: none !important;
        }

        .toggle-cursor {
            background: #ff9500 !important;
        }

        .toggle-cursor:hover {
            background: #e08600 !important;
        }
    </style>
</head>

<body>
    <canvas id="cursorFollower" width="32" height="32"></canvas>

    <div class="container">
        <h1>Spinner Cursor Generator</h1>
        <p class="subtitle">Generate animated cursor frames from the macOS spinner</p>

        <svg width="0" height="0" style="position:absolute">
            <defs>
                <clipPath id="cursorBlade" clipPathUnits="objectBoundingBox">
                    <path id="cursorBladePath" d="M 0.5,0.5 L 0.5,0 L 1,0 Z" />
                </clipPath>
            </defs>
        </svg>

        <div class="preview-section">
            <div class="spinner-preview">
                <canvas id="previewCanvas" width="64" height="64"></canvas>
            </div>
            <div class="frames-preview">
                <h3>Generated Frames</h3>
                <div class="frames-grid" id="framesGrid"></div>
            </div>
        </div>

        <div class="controls">
            <div class="control-row">
                <label>Cursor Size</label>
                <input type="range" id="sizeRange" min="16" max="128" value="32">
                <span class="value" id="sizeValue">32px</span>
            </div>
            <div class="control-row">
                <label>Frame Count</label>
                <input type="range" id="frameRange" min="4" max="36" value="12">
                <span class="value" id="frameValue">12</span>
            </div>
            <div class="control-row">
                <label>Frame Rate</label>
                <input type="range" id="fpsRange" min="5" max="30" value="15">
                <span class="value" id="fpsValue">15 fps</span>
            </div>
        </div>

        <div class="buttons">
            <button id="generateBtn">Generate Frames</button>
            <button id="downloadZipBtn">Download All Frames (ZIP)</button>
            <button id="downloadGifBtn">Download as GIF</button>
            <button id="downloadAniBtn">Download as .ani (Windows)</button>
        </div>

        <div class="status" id="status"></div>

        <div class="info">
            <strong>How to use:</strong><br><br>
            <strong>macOS:</strong> Use the GIF or PNG frames with tools like <code>Mousecape</code> to create custom cursors.<br><br>
            <strong>Windows:</strong> Download the <code>.ani</code> file and set it as your cursor in Mouse Settings → Additional mouse options → Pointers.<br><br>
            <strong>Linux:</strong> Use the PNG frames to create an <code>xcursor</code> theme.
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gif.js/0.2.0/gif.js"></script>
    <script>
        // Spinner settings (from your preferences)
        const SETTINGS = {
            background: 'smooth-rainbow',
            bladeWidth: 38,
            curvature: 0.24,
            opacity: 0.25
        };

        // Rainbow colors for smooth-rainbow (matches CSS exactly)
        // CSS: conic-gradient(from 0deg, #7b68ee, #4169e1, #00bfff, #00fa9a, #32cd32, #9acd32, #ffd700, #ff8c00, #ff4500, #ff1493, #7b68ee)
        const RAINBOW_COLORS = [
            '#7b68ee', '#4169e1', '#00bfff', '#00fa9a', '#32cd32',
            '#9acd32', '#ffd700', '#ff8c00', '#ff4500', '#ff1493', '#7b68ee'
        ];

        const previewCanvas = document.getElementById('previewCanvas');
        const previewCtx = previewCanvas.getContext('2d');
        const framesGrid = document.getElementById('framesGrid');

        const sizeRange = document.getElementById('sizeRange');
        const frameRange = document.getElementById('frameRange');
        const fpsRange = document.getElementById('fpsRange');
        const sizeValue = document.getElementById('sizeValue');
        const frameValue = document.getElementById('frameValue');
        const fpsValue = document.getElementById('fpsValue');

        let frames = [];
        let animationId;

        // Update value displays
        sizeRange.addEventListener('input', () => {
            sizeValue.textContent = sizeRange.value + 'px';
            previewCanvas.width = previewCanvas.height = parseInt(sizeRange.value);
        });
        frameRange.addEventListener('input', () => frameValue.textContent = frameRange.value);
        fpsRange.addEventListener('input', () => fpsValue.textContent = fpsRange.value + ' fps');

        function getBladeClipPath(widthDeg, curve) {
            const halfWidth = widthDeg / 2;
            const cx = 0.5, cy = 0.5, r = 0.5;

            const startAngle = (-90 - halfWidth) * (Math.PI / 180);
            const endAngle = (-90 + halfWidth) * (Math.PI / 180);

            const x1 = cx + r * Math.cos(startAngle);
            const y1 = cy + r * Math.sin(startAngle);
            const x2 = cx + r * Math.cos(endAngle);
            const y2 = cy + r * Math.sin(endAngle);

            const cpR = 0.25;
            const curveShift = curve * Math.PI;

            const cp1x = cx + cpR * Math.cos(startAngle + curveShift);
            const cp1y = cy + cpR * Math.sin(startAngle + curveShift);
            const cp2x = cx + cpR * Math.cos(endAngle + curveShift);
            const cp2y = cy + cpR * Math.sin(endAngle + curveShift);

            return { cx, cy, x1, y1, x2, y2, cp1x, cp1y, cp2x, cp2y, r };
        }

        function drawSpinner(ctx, size, rotation = 0) {
            const cx = size / 2;
            const cy = size / 2;
            const r = size / 2;

            ctx.clearRect(0, 0, size, size);

            // Draw rainbow background
            // CSS uses "from 0deg" which is top (12 o'clock), canvas conic starts at 3 o'clock
            // So we need to rotate by -90deg (-Math.PI/2)
            const gradient = ctx.createConicGradient(-Math.PI / 2, cx, cy);

            // Distribute colors evenly (11 colors including closing repeat)
            for (let i = 0; i < RAINBOW_COLORS.length; i++) {
                gradient.addColorStop(i / (RAINBOW_COLORS.length - 1), RAINBOW_COLORS[i]);
            }

            ctx.beginPath();
            ctx.arc(cx, cy, r, 0, Math.PI * 2);
            ctx.fillStyle = gradient;
            ctx.fill();

            // Draw blades
            const blade = getBladeClipPath(SETTINGS.bladeWidth, SETTINGS.curvature);
            ctx.fillStyle = `rgba(0, 0, 0, ${SETTINGS.opacity})`;

            for (let i = 0; i < 5; i++) {
                const angle = rotation + (i * 72) * (Math.PI / 180);

                ctx.save();
                ctx.translate(cx, cy);
                ctx.rotate(angle);
                ctx.translate(-cx, -cy);

                // Draw blade shape
                ctx.beginPath();
                ctx.moveTo(blade.cx * size, blade.cy * size);
                ctx.quadraticCurveTo(
                    blade.cp1x * size, blade.cp1y * size,
                    blade.x1 * size, blade.y1 * size
                );
                ctx.arc(cx, cy, r,
                    Math.atan2(blade.y1 - 0.5, blade.x1 - 0.5),
                    Math.atan2(blade.y2 - 0.5, blade.x2 - 0.5)
                );
                ctx.quadraticCurveTo(
                    blade.cp2x * size, blade.cp2y * size,
                    blade.cx * size, blade.cy * size
                );
                ctx.fill();

                ctx.restore();
            }

            // Add Aqua gloss effect - top shine
            // CSS: top: 5%, height: 40%, width: 70%, opacity 0.7->0.1, blur 2px, border-radius: 50% 50% 40% 40%
            const shineTop = size * 0.05;
            const shineHeight = size * 0.4;
            const shineWidth = size * 0.7;

            const shineGradient = ctx.createLinearGradient(cx, shineTop, cx, shineTop + shineHeight);
            shineGradient.addColorStop(0, 'rgba(255, 255, 255, 0.7)');
            shineGradient.addColorStop(1, 'rgba(255, 255, 255, 0.1)');

            ctx.beginPath();
            // Ellipse centered vertically within the shine area
            ctx.ellipse(cx, shineTop + shineHeight / 2, shineWidth / 2, shineHeight / 2, 0, 0, Math.PI * 2);
            ctx.fillStyle = shineGradient;
            ctx.fill();

            // Bottom glow
            // CSS: bottom: 8%, height: 30%, width: 60%, opacity 0.05->0.25, blur 3px
            const glowBottom = size * 0.08;
            const glowHeight = size * 0.3;
            const glowWidth = size * 0.6;
            const glowCenterY = size - glowBottom - glowHeight / 2;

            const glowGradient = ctx.createLinearGradient(cx, glowCenterY - glowHeight / 2, cx, glowCenterY + glowHeight / 2);
            glowGradient.addColorStop(0, 'rgba(255, 255, 255, 0.05)');
            glowGradient.addColorStop(1, 'rgba(255, 255, 255, 0.25)');

            ctx.beginPath();
            ctx.ellipse(cx, glowCenterY, glowWidth / 2, glowHeight / 2, 0, 0, Math.PI * 2);
            ctx.fillStyle = glowGradient;
            ctx.fill();
        }

        // Animate preview
        // Match CSS: animation-duration = 1/speed seconds (speed 1.2 = 0.833s per rotation)
        let previewRotation = 0;
        let lastTime = 0;
        function animatePreview(timestamp) {
            if (!lastTime) lastTime = timestamp;
            const deltaTime = (timestamp - lastTime) / 1000; // seconds
            lastTime = timestamp;

            const size = parseInt(sizeRange.value);
            previewCanvas.width = previewCanvas.height = size;

            // Speed 1.2 means 1.2 rotations per second
            // CSS uses: animation-duration: (1 / speed)s = 0.833s for speed 1.2
            const speed = 1.2; // Fixed to match your settings
            const rotationsPerSecond = speed;
            previewRotation += deltaTime * rotationsPerSecond * Math.PI * 2;

            drawSpinner(previewCtx, size, previewRotation);
            animationId = requestAnimationFrame(animatePreview);
        }
        requestAnimationFrame(animatePreview);

        // Generate frames
        document.getElementById('generateBtn').addEventListener('click', () => {
            const size = parseInt(sizeRange.value);
            const frameCount = parseInt(frameRange.value);

            frames = [];
            framesGrid.innerHTML = '';

            for (let i = 0; i < frameCount; i++) {
                const canvas = document.createElement('canvas');
                canvas.width = canvas.height = size;
                const ctx = canvas.getContext('2d');

                const rotation = (i / frameCount) * Math.PI * 2;
                drawSpinner(ctx, size, rotation);

                frames.push(canvas);

                // Add to preview grid
                const thumb = document.createElement('canvas');
                thumb.width = thumb.height = 32;
                const thumbCtx = thumb.getContext('2d');
                thumbCtx.drawImage(canvas, 0, 0, 32, 32);
                framesGrid.appendChild(thumb);
            }

            showStatus('success', `Generated ${frameCount} frames at ${size}x${size}px`);
        });

        // Download as ZIP
        document.getElementById('downloadZipBtn').addEventListener('click', async () => {
            if (frames.length === 0) {
                showStatus('error', 'Generate frames first!');
                return;
            }

            const zip = new JSZip();
            const folder = zip.folder('spinner-cursor-frames');

            for (let i = 0; i < frames.length; i++) {
                const dataUrl = frames[i].toDataURL('image/png');
                const base64 = dataUrl.split(',')[1];
                folder.file(`frame_${String(i).padStart(3, '0')}.png`, base64, { base64: true });
            }

            const blob = await zip.generateAsync({ type: 'blob' });
            downloadBlob(blob, 'spinner-cursor-frames.zip');
            showStatus('success', 'Downloaded ZIP with PNG frames');
        });

        // Download as GIF
        document.getElementById('downloadGifBtn').addEventListener('click', () => {
            if (frames.length === 0) {
                showStatus('error', 'Generate frames first!');
                return;
            }

            const size = parseInt(sizeRange.value);
            const fps = parseInt(fpsRange.value);
            const delay = Math.round(1000 / fps);

            const gif = new GIF({
                workers: 2,
                quality: 10,
                width: size,
                height: size,
                workerScript: 'https://cdnjs.cloudflare.com/ajax/libs/gif.js/0.2.0/gif.worker.js',
                transparent: 0x000000
            });

            frames.forEach(canvas => {
                gif.addFrame(canvas, { delay, copy: true });
            });

            gif.on('finished', blob => {
                downloadBlob(blob, 'spinner-cursor.gif');
                showStatus('success', 'Downloaded animated GIF');
            });

            gif.render();
            showStatus('success', 'Generating GIF...');
        });

        // Download as .ani (Windows animated cursor)
        document.getElementById('downloadAniBtn').addEventListener('click', async () => {
            if (frames.length === 0) {
                showStatus('error', 'Generate frames first!');
                return;
            }

            try {
                const aniBlob = await createAniCursor(frames, parseInt(fpsRange.value));
                downloadBlob(aniBlob, 'spinner-cursor.ani');
                showStatus('success', 'Downloaded .ani cursor file');
            } catch (e) {
                showStatus('error', 'Error creating .ani: ' + e.message);
            }
        });

        async function createAniCursor(frames, fps) {
            const jiffies = Math.round(60 / fps); // ANI uses jiffies (1/60th second)
            const size = frames[0].width;

            // Convert frames to ICO format
            const icoFrames = [];
            for (const frame of frames) {
                const ico = await canvasToIco(frame, size);
                icoFrames.push(ico);
            }

            // Build ANI file
            const anih = createAnihChunk(icoFrames.length, icoFrames.length, size, size, 32, 1, jiffies);
            const listFrames = createListChunk(icoFrames);

            const riffSize = 4 + anih.length + listFrames.length;
            const ani = new Uint8Array(8 + riffSize);
            const view = new DataView(ani.buffer);

            let offset = 0;
            // RIFF header
            ani.set(stringToBytes('RIFF'), offset); offset += 4;
            view.setUint32(offset, riffSize, true); offset += 4;
            ani.set(stringToBytes('ACON'), offset); offset += 4;

            // anih chunk
            ani.set(anih, offset); offset += anih.length;

            // LIST chunk with frames
            ani.set(listFrames, offset);

            return new Blob([ani], { type: 'application/octet-stream' });
        }

        function createAnihChunk(numFrames, numSteps, width, height, bitCount, numPlanes, jiffies) {
            const chunk = new Uint8Array(8 + 36);
            const view = new DataView(chunk.buffer);

            let offset = 0;
            chunk.set(stringToBytes('anih'), offset); offset += 4;
            view.setUint32(offset, 36, true); offset += 4; // chunk size

            view.setUint32(offset, 36, true); offset += 4; // header size
            view.setUint32(offset, numFrames, true); offset += 4;
            view.setUint32(offset, numSteps, true); offset += 4;
            view.setUint32(offset, width, true); offset += 4;
            view.setUint32(offset, height, true); offset += 4;
            view.setUint32(offset, bitCount, true); offset += 4;
            view.setUint32(offset, numPlanes, true); offset += 4;
            view.setUint32(offset, jiffies, true); offset += 4;
            view.setUint32(offset, 1, true); // flags: AF_ICON

            return chunk;
        }

        function createListChunk(icoFrames) {
            let totalSize = 4; // 'fram'
            for (const ico of icoFrames) {
                totalSize += 8 + ico.length; // 'icon' + size + data
                if (ico.length % 2) totalSize++; // padding
            }

            const list = new Uint8Array(8 + totalSize);
            const view = new DataView(list.buffer);

            let offset = 0;
            list.set(stringToBytes('LIST'), offset); offset += 4;
            view.setUint32(offset, totalSize, true); offset += 4;
            list.set(stringToBytes('fram'), offset); offset += 4;

            for (const ico of icoFrames) {
                list.set(stringToBytes('icon'), offset); offset += 4;
                view.setUint32(offset, ico.length, true); offset += 4;
                list.set(ico, offset); offset += ico.length;
                if (ico.length % 2) offset++; // padding
            }

            return list;
        }

        async function canvasToIco(canvas, size) {
            // Get image data
            const ctx = canvas.getContext('2d');
            const imageData = ctx.getImageData(0, 0, size, size);
            const pixels = imageData.data;

            // Create ICO structure
            const bmpSize = size * size * 4;
            const maskSize = Math.ceil(size / 8) * size;
            const icoSize = 22 + 40 + bmpSize + maskSize;

            const ico = new Uint8Array(icoSize);
            const view = new DataView(ico.buffer);

            let offset = 0;

            // ICO header
            view.setUint16(offset, 0, true); offset += 2; // reserved
            view.setUint16(offset, 1, true); offset += 2; // type: icon
            view.setUint16(offset, 1, true); offset += 2; // count

            // ICO directory entry
            ico[offset++] = size < 256 ? size : 0; // width
            ico[offset++] = size < 256 ? size : 0; // height
            ico[offset++] = 0; // color palette
            ico[offset++] = 0; // reserved
            view.setUint16(offset, 1, true); offset += 2; // color planes
            view.setUint16(offset, 32, true); offset += 2; // bits per pixel
            view.setUint32(offset, 40 + bmpSize + maskSize, true); offset += 4; // size
            view.setUint32(offset, 22, true); offset += 4; // offset to BMP

            // BMP info header
            view.setUint32(offset, 40, true); offset += 4; // header size
            view.setInt32(offset, size, true); offset += 4; // width
            view.setInt32(offset, size * 2, true); offset += 4; // height (doubled for XOR+AND mask)
            view.setUint16(offset, 1, true); offset += 2; // planes
            view.setUint16(offset, 32, true); offset += 2; // bits per pixel
            view.setUint32(offset, 0, true); offset += 4; // compression
            view.setUint32(offset, bmpSize + maskSize, true); offset += 4; // image size
            view.setInt32(offset, 0, true); offset += 4; // x pixels per meter
            view.setInt32(offset, 0, true); offset += 4; // y pixels per meter
            view.setUint32(offset, 0, true); offset += 4; // colors used
            view.setUint32(offset, 0, true); offset += 4; // important colors

            // Pixel data (bottom-up, BGRA)
            for (let y = size - 1; y >= 0; y--) {
                for (let x = 0; x < size; x++) {
                    const srcIdx = (y * size + x) * 4;
                    ico[offset++] = pixels[srcIdx + 2]; // B
                    ico[offset++] = pixels[srcIdx + 1]; // G
                    ico[offset++] = pixels[srcIdx + 0]; // R
                    ico[offset++] = pixels[srcIdx + 3]; // A
                }
            }

            // AND mask (all zeros for full opacity with alpha channel)
            for (let i = 0; i < maskSize; i++) {
                ico[offset++] = 0;
            }

            return ico;
        }

        function stringToBytes(str) {
            return new Uint8Array([...str].map(c => c.charCodeAt(0)));
        }

        function downloadBlob(blob, filename) {
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            a.click();
            URL.revokeObjectURL(url);
        }

        function showStatus(type, message) {
            const status = document.getElementById('status');
            status.className = 'status ' + type;
            status.textContent = message;
        }

        // Initial frame generation
        document.getElementById('generateBtn').click();
    </script>
</body>

</html>
